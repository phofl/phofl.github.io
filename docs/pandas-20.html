<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="https://phofl.github.io/theme/css/style.less">
  <script src="//cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="icon" type="image/vnd.microsoft.icon" href="https://phofl.github.io/">
  <link rel="stylesheet" type="text/css" href="https://phofl.github.io/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="https://phofl.github.io/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Roboto+Mono">
  <link rel="stylesheet" type="text/css" href="https://phofl.github.io/theme/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="https://phofl.github.io/theme/css/hatena-bookmark-icon.css">
  <link rel="stylesheet" type="text/css" href="/docs/extra/custom.css">


  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Patrick Hoefler">
  <meta name="description" content="Posts and writings by Patrick Hoefler">

  <link href="https://phofl.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Patrick Hoefler Atom" />

<meta name="keywords" content="pandas">

  <title>
    Patrick Hoefler
&ndash; Welcoming pandas 2.0  </title>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'G-SE6TX73EFF']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <main>
    <header>
      <div class="site-name">
        <a href="https://phofl.github.io">Patrick Hoefler</a>
      </div>
      <p>
        <a href="https://phofl.github.io/archives.html"><i class="fa fa-archive"></i> Archive</a>
      </p>
    </header>

<article>
  <div class="article__title">
    <h1><a href="https://phofl.github.io/pandas-20.html">Welcoming pandas 2.0</a></h1>
  </div>
  <div class="article__meta">
    <p class="article__meta__post-date">Posted on: Thu 23 March 2023</p>
 Tags:
      <a href="https://phofl.github.io/tag/pandas.html">#pandas</a>    </p>
  </div>
  <div class="article__text">
    <p><em>How the API is changing and how to leverage new functionalities</em></p>
<h2 id="introduction">Introduction</h2>
<p>After 3 years of development, the second pandas 2.0 release candidate was released on the 16th of 
March. There are many new features in pandas 2.0, including improved extension array
support, pyarrow support for DataFrames and non-nanosecond datetime resolution, but also
many enforced deprecations and hence API changes. Before we investigate how new features can improve
your workflow, we take a look at some enforced deprecations.</p>
<h2 id="api-changes">API changes</h2>
<p>The 2.0 release is a major release for pandas (check out the 
<a href="https://pandas.pydata.org/docs/development/policies.html#version-policy">versioning policy</a>), 
hence all deprecations added in the 1.x series were enforced.
There were around 150 different warnings in the latest 1.5.3 release. If your code runs without
warnings on 1.5.3, you should be good to go on 2.0. We will have a quick look at some
subtle or more noticeable deprecations before jumping into new features. You can check out the
complete release notes <a href="https://pandas.pydata.org/docs/dev/whatsnew/v2.0.0.html">here</a>.</p>
<h3 id="index-now-supports-arbitrary-numpy-dtypes">Index now supports arbitrary NumPy dtypes</h3>
<p>Before the 2.0 release, an <code>Index</code> only supported <code>int64</code>, <code>float64</code> and <code>uint64</code> dtypes 
which resulted in an <code>Int64Index</code>, <code>Float64Index</code> or <code>UInt64Index</code>. These classes where 
removed. All numeric indexes are now represented as <code>Index</code> with an associated dtype, e.g.:</p>
<pre><code class="language-python">In [1]: pd.Index([1, 2, 3], dtype=&quot;int64&quot;)
Out[1]: Index([1, 2, 3], dtype='int64')
In [2]: pd.Index([1, 2, 3], dtype=&quot;int32&quot;)
Out[2]: Index([1, 2, 3], dtype='int32')
</code></pre>
<p>This mirrors the behavior for extension array backed Indexes. An Index can hold arbitrary extension 
array dtypes since pandas 1.4.0. You can check the 
<a href="https://pandas.pydata.org/docs/dev/whatsnew/v2.0.0.html#index-can-now-hold-numpy-numeric-dtypes">release notes</a> 
for further information. This change is only noticeable when an explicit Index subclass, that no
longer exists, is used.</p>
<h3 id="behavior-change-in-numeric_only-for-aggregation-functions">Behavior change in <code>numeric_only</code> for aggregation functions</h3>
<p>In previous versions you could call aggregation functions on a DataFrame with mixed-dtypes and
got varying results. Sometimes the aggregation worked and excluded non-numeric dtypes, in some
other cases an error was raised. The <code>numeric_only</code> argument is now consistent and the aggregation
will raise if you apply it on a DataFrame with non-numeric dtypes. You can set <code>numeric_only</code>
to <code>True</code> or restrict your DataFrame to numeric columns, if you want to get the same behavior
as before. This will avoid accidentally dropping relevant columns from the <code>DataFrame</code>.</p>
<p>Calculating the mean over a DataFrame dropped non-numeric columns before 2.0:</p>
<pre><code class="language-python">In[2] df = DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]})
In[3] df.mean()
Out[3]: 
a    2.0
dtype: float64
</code></pre>
<p>This operation now raises an error to avoid dropping relevant columns in these aggregations:</p>
<pre><code class="language-python">TypeError: Could not convert ['xyz'] to numeric
</code></pre>
<h2 id="improvements-and-new-features">Improvements and new features</h2>
<p>pandas 2.0 brings a some interesting new functionalities like PyArrow-backed DataFrames, 
non-nanosecond resolution/accuracy for timestamps and many Copy-on-Write improvements. Let's take
a closer look at some of those now.</p>
<h3 id="improved-support-for-nullable-dtypes-and-extension-arrays">Improved support for nullable dtypes and extension arrays</h3>
<p>The 2.0 release brings a vast improvement for nullable dtypes and extension arrays in general.
Internally, many operations now use nullable semantics instead of casting to object when
using nullable dtypes like <code>Int64</code>, <code>boolean</code> or <code>Float64</code>. The internal handling of extension
arrays got consistently better over the 1.x series. This is visible through
a bunch of significant performance improvements:</p>
<p>On pandas 2.0:</p>
<pre><code class="language-python">In[3]: ser = pd.Series(list(range(1, 1_000_000)) + [pd.NA], dtype=&quot;Int64&quot;)
In[4]: %timeit ser.drop_duplicates()
7.54 ms ± 24 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>On pandas 1.5.3:</p>
<pre><code class="language-python">In[3]: ser = pd.Series(list(range(1, 1_000_000)) + [pd.NA], dtype=&quot;Int64&quot;)
In[4]: %timeit ser.drop_duplicates()
22.7 ms ± 272 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre>
<p>Additionally, many operations now properly operate on the nullable arrays which maintains the
appropriate dtype when returning the result. All groupby algorithms now use nullable semantics,
which results in better accuracy (previously the input was cast to float which might have let
to a loss of precision) and performance improvements.</p>
<p>To improve opting into nullable dtypes, a new keyword <code>dtype_backen</code> which returns
a <code>DataFrame</code> completely backed by nullable dtypes when set to <code>"numpy_nullable"</code> was added to 
most I/O functions. In addition to using nullable dtypes for numeric columns, 
this option results in a <code>DataFrame</code> that uses the pandas <code>StringDtype</code>
instead of a NumPy array with dtype <code>object</code>. Based on the storage option, the string columns
are either backed by Python strings or by PyArrow strings. The PyArrow alternative is generally
faster than the Python strings.</p>
<p>The <code>Index</code> and <code>MultiIndex</code> classes are now better integrated with extension
arrays in general. General Extension Array support was introduced in 1.4. A quick overview of what
this entails:</p>
<ul>
<li>Using extension array semantics for operations on the index</li>
<li>Efficient Indexing operations on nullable and pyarrow dtypes</li>
<li>No materialization of MultiIndexes to improve performance and maintain dtypes</li>
</ul>
<p>The Extension Array interface is continuously improving and continues to avoid materializing NumPy 
arrays and instead relies on the provided extension array implementation in a growing number
of methods. Some areas are still under development, including GroupBy aggregations for third party 
extension arrays.</p>
<h3 id="pyarrow-backed-dataframes">Pyarrow-backed DataFrames</h3>
<p>Version 1.5.0 brought a new extension array to pandas that enables users to create <code>DataFrames</code>
backed by PyArrow arrays. We expect these extension arrays to provide a vast improvement when
operating on string-columns, since the NumPy object representation is not very efficient. The
string representation is mostly equivalent to<code>string[pyarrow]</code> that has been around for quite some 
time. The PyArrow-specific extension array supports all other PyArrow dtypes on top of it. Users can 
now create columns with any PyArrow dtype and/or use PyArrow nullable semantics. Those
come out of the box when using PyArrow dtypes. A PyArrow-backed column can be requested 
specifically by casting to or specifying a column's dtype as <code>f"{dtype}[pyarrow]"</code>, e.g. 
<code>"int64[pyarrow]"</code> for an integer column. Alternatively, a PyArrow dtype can be created through:</p>
<pre><code class="language-python">import pandas as pd
import pyarrow as pa

dtype = pd.ArrowDtype(pa.int64)
</code></pre>
<p>The API in 1.5.0 was pretty raw and experimental and fell back to NumPy quite often. With pandas 2.0 and an 
increased minimum version of PyArrow (7.0 for pandas 2.0), we can now utilize the corresponding PyArrow compute 
functions in many more methods. This improves performance significantly and gets rid of many
<code>PerformanceWarnings</code> that were raised before when falling back to NumPy. Similarly to the
nullable dtypes, most I/O methods can return PyArrow-backed DataFrames through the keyword
<code>dtype_backend="pyarrow"</code></p>
<p>Future versions of pandas will bring many more improvements in this area!</p>
<p>Some I/O methods have specific PyArrow engines, like <code>read_csv</code> and <code>read_json</code>, which bring
a significant performance improvement when requesting PyArrow-backed <code>DataFrames</code>. They don't 
support all options that the original implementations support yet. Check out a more <a href="https://datapythonista.me/blog/pandas-20-and-the-arrow-revolution-part-i">in-depth
exploration</a> from Marc 
Garcia.</p>
<h3 id="non-nanosecond-resolution-in-timestamps">Non-nanosecond resolution in Timestamps</h3>
<p>A long-standing issue in pandas was that timestamps were always represented in nanosecond 
resolution. As a consequence, there was no way of representing dates before the 1st of January
1970 or after the 11th of April 2264. This caused pains in the research community when analyzing
timeseries data that spanned over millennia and more.</p>
<p>The 2.0 release introduces support for other resolutions, e.g. support for second, millisecond
and microsecond resolution was added. This enables time ranges up to <code>+/- 2.9e11 years</code> and thus 
should cover most common use-cases.</p>
<p>On previous versions, passing a date to the <code>Timestamp</code> constructor that was out of the supported
range raised an error no matter what unit was specified. With pandas 2.0 the unit is honored, and
thus you can create arbitrary dates:</p>
<pre><code class="language-python">In[5]: pd.Timestamp(&quot;1000-10-11&quot;, unit=&quot;s&quot;)
Out[5]: Timestamp('1000-10-11 00:00:00')
</code></pre>
<p>The timestamp is only returned up to the second, higher precisions are not supported when specifying
<code>unit="s"</code>.</p>
<p>Support for non-nanosecond resolutions of timestamps is still actively developed. Many
methods relied on the assumption that a timestamp was always given in nanosecond resolution. It is
a lot of work to get rid of these problems everywhere and hence you might still encounter some
bugs in different areas.</p>
<h3 id="copy-on-write-improvements">Copy-on-Write improvements</h3>
<p>Copy-on-Write (CoW) was originally introduced in pandas 1.5.0. Check out my initial post introducing
<a href="https://phofl.github.io/cow-introduction.html">Copy-on-Write</a>.</p>
<blockquote>
<p><strong>Short summary:</strong></p>
<p><strong>Any DataFrame or Series derived from another in</strong> 
<strong>any way always behaves as a copy</strong>. As a consequence, we can only change the values of an object 
through modifying the object itself. CoW disallows updating a DataFrame or a Series that shares 
data with another DataFrame or Series object inplace.</p>
</blockquote>
<p>Version 1.5 provided the general mechanism but not much apart from that. A couple of bugs where 
Copy-on-Write was not respected, and hence two objects could get modified with one operation, were
discovered and fixed since then.</p>
<p>More importantly, nearly all methods now utilize a <em>lazy copy</em> mechanism to avoid copying the
underlying data as long as possible. Without CoW enabled, most methods perform defensive copies 
to avoid side effects when an object is modified later on. This results in high memory usage and a
relatively high runtime. Copy-on-Write enables us to remove all defensive copies and defer
the actual copies until the data of an object are modified.</p>
<p>Additionally, CoW provides a cleaner and easier to work with API and should give your code a
performance boost on top of it. Generally, if an application does not rely on updating more than one object at
once and does not utilize chained assignment, the risk of turning Copy-on-Write 
on is minor. I've tested it on some code-bases and saw promising performance improvements, so I'd recommend
trying it out to see how it impacts your code. We are currently planning on making CoW the default in the next
major release. I'd recommend developing new features with Copy-on-Write enabled
to avoid migration issues later on.</p>
<p>A PDEP (pandas development enhancement proposal) was submitted to deprecate and remove the
<code>inplace</code> and <code>copy</code> keyword in most methods. Those would become obsolete with Copy-on-Write
enabled and would only add confusion for users. You can follow this discussion 
<a href="https://github.com/pandas-dev/pandas/pull/51466">here</a>. If accepted, the removal of both keywords
will happen when CoW is made the default.</p>
<h2 id="conclusion">Conclusion</h2>
<p>pandas 2.0 brings many new and exiting features. We've seen a couple of them and looked at how
to utilize them. </p>
<p>Thank you for reading. Feel free to reach out in the comments to share your thoughts and feedback 
on the 2.0 release. I will write additional posts focusing on Copy-on-Write and how to get the
most out of it. Follow me on Medium if you like to read more about pandas in general.</p>
  </div>

</article>


  </main>
    <footer>
      <section class="author">
        <div class="author__name">
          <a href="https://phofl.github.io/pages/about.html">Patrick Hoefler</a>
          <p></p>
        </div>
        <div class="author__link">
          <ul>
            <li><a href="https://phofl.github.io/pages/about.html" title="About"><i class="fa fa-link"></i></a></li>
            <li>
              <a href="https://github.com/phofl/" target="_blank" title="github">
                <i class="fa fa-github-square"></i>
              </a>
            </li>
            <li>
              <a href="https://www.linkedin.com/in/patrick-hoefler/" target="_blank" title="linkedin">
                <i class="fa fa-linkedin-square"></i>
              </a>
            </li>
            <li>
              <a href="mailto:patrick_hoefler@gmx.net" target="_blank" title="mail">
                <i class="fa fa-envelope"></i>
              </a>
            </li>
            <li>
              <a href="https://phofl.github.io/feeds/all.atom.xml" target="_blank" title="Feed">
                <i class="fa fa-rss"></i>
              </a>
            </li>
          </ul>
        </div>
      </section>
      <div class="ending-message">
        <p>&copy; Patrick Hoefler. Powered by <a href="http://getpelican.com" target="_blank">Pelican</a>, Theme is using <a href="https://github.com/laughk/pelican-hss" target="_blank">HSS</a>. </p>
      </div>
    </footer>
</body>
</html>