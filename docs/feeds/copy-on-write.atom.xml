<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Patrick Hoefler - copy-on-write</title><link href="https://phofl.github.io/" rel="alternate"></link><link href="https://phofl.github.io/feeds/copy-on-write.atom.xml" rel="self"></link><id>https://phofl.github.io/</id><updated>2023-09-29T00:00:00+02:00</updated><entry><title>Deep dive into pandas Copy-on-Write mode - part III</title><link href="https://phofl.github.io/cow-adaptions.html" rel="alternate"></link><published>2023-09-29T00:00:00+02:00</published><updated>2023-09-29T00:00:00+02:00</updated><author><name>Patrick Hoefler</name></author><id>tag:phofl.github.io,2023-09-29:/cow-adaptions.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Explaining the migration path for Copy-on-Write&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The introduction of Copy-on-Write (CoW) is a breaking change that will have some impact on existing
pandas-code. We will investigate how we can adapt our code to avoid errors when CoW will be
enabled by default. This is currently planned for the pandas …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Explaining the migration path for Copy-on-Write&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The introduction of Copy-on-Write (CoW) is a breaking change that will have some impact on existing
pandas-code. We will investigate how we can adapt our code to avoid errors when CoW will be
enabled by default. This is currently planned for the pandas 3.0 release, which is scheduled for April 2024.
&lt;a href="https://towardsdatascience.com/deep-dive-into-pandas-copy-on-write-mode-part-i-26982e7408c6"&gt;The first post&lt;/a&gt; in this series explained the behavior of Copy-on-Write 
while &lt;a href="https://towardsdatascience.com/deep-dive-into-pandas-copy-on-write-mode-part-ii-b023432a5334"&gt;the second post&lt;/a&gt; dove into performance optimizations that are related to Copy-on-Write.&lt;/p&gt;
&lt;p&gt;We are planning on adding a warning mode that will warn for all operations that will change
behavior with CoW. The warning will be very noisy for users and thus has to be treated with some care.
This post explains common cases and how you can adapt your code to avoid changes in behavior.&lt;/p&gt;
&lt;h2 id="chained-assignment"&gt;Chained assignment&lt;/h2&gt;
&lt;p&gt;Chained assignment is a technique where one object is updated through 2 subsequent operations.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pandas as pd

df = pd.DataFrame({&amp;quot;x&amp;quot;: [1, 2, 3]})

df[&amp;quot;x&amp;quot;][df[&amp;quot;x&amp;quot;] &amp;gt; 1] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first operation selects the column &lt;code&gt;"x"&lt;/code&gt; while the second operation restricts the number
of rows. There are many different combinations of these operations (e.g. combined with &lt;code&gt;loc&lt;/code&gt; or
&lt;code&gt;iloc&lt;/code&gt;). None of these combinations will work under CoW. Instead, they will raise a warning 
&lt;code&gt;ChainedAssignmentError&lt;/code&gt; to remove these patterns instead of silently doing nothing.&lt;/p&gt;
&lt;p&gt;Generally, you can use &lt;code&gt;loc&lt;/code&gt; instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df.loc[df[&amp;quot;x&amp;quot;] &amp;gt; 1, &amp;quot;x&amp;quot;] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first dimension of &lt;code&gt;loc&lt;/code&gt; always corresponds to the &lt;code&gt;row-indexer&lt;/code&gt;. This means that you are
able to select a subset of rows. The second dimension corresponds to the &lt;code&gt;column-indexer&lt;/code&gt;, which
enables you to select a subset of columns. &lt;/p&gt;
&lt;p&gt;It is generally faster using &lt;code&gt;loc&lt;/code&gt; when you want to set values into a subset of rows, so this
will clean up your code and provide a performance improvement.&lt;/p&gt;
&lt;p&gt;This is the obvious case where CoW will have an impact. It will also impact chained inplace 
operations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df[&amp;quot;x&amp;quot;].replace(1, 100)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The pattern is the same as above. The column selection is the first operation. The &lt;code&gt;replace&lt;/code&gt;
method tries to operate on the temporary object, which will fail to update the initial object.
You can also remove these patterns pretty easily through specifying the columns you want to
operate on.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = df.replace({&amp;quot;x&amp;quot;: 1}, {&amp;quot;x&amp;quot;: 100})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="patterns-to-avoid"&gt;Patterns to avoid&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://medium.com/towards-data-science/deep-dive-into-pandas-copy-on-write-mode-part-i-26982e7408c6"&gt;My previous post&lt;/a&gt; explains how the CoW mechanism works and how DataFrames share the underlying data. A
defensiv copy will be performed if two objects share the same data while you are modifying one
object inplace.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df2 = df.reset_index()
df2.iloc[0, 0] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;reset_index&lt;/code&gt; operation will create a view of the underlying data. The result is assigned to 
a new variable &lt;code&gt;df2&lt;/code&gt;, this means that two objects share the same data. This holds true until
&lt;code&gt;df&lt;/code&gt; is garbage collected. The &lt;code&gt;setitem&lt;/code&gt; operation
will thus trigger a copy. This is completely unnecessary if you don't need the initial object 
&lt;code&gt;df&lt;/code&gt; anymore. Simply reassigning to the same variable will invalidate the reference that is
held by the object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = df.reset_index()
df.iloc[0, 0] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Summarizing, creating multiple references in the same method keeps unnecessary references alive.&lt;/p&gt;
&lt;p&gt;Temporary references that are created when chaining different methods together are fine.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = df.reset_index().drop(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will only keep one reference alive.&lt;/p&gt;
&lt;h2 id="accessing-the-underlying-numpy-array"&gt;Accessing the underlying NumPy array&lt;/h2&gt;
&lt;p&gt;pandas currently gives us access to the underlying NumPy array through &lt;code&gt;to_numpy&lt;/code&gt; or &lt;code&gt;.values&lt;/code&gt;.
The returned array is a copy, if your DataFrame consists of different dtypes, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;a&amp;quot;: [1, 2], &amp;quot;b&amp;quot;: [1.5, 2.5]})
df.to_numpy()

[[1.  1.5]
 [2.  2.5]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The DataFrame is backed by two arrays which have to be combined into one. This triggers the copy.&lt;/p&gt;
&lt;p&gt;The other case is a DataFrame that is only backed by a single NumPy array, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;a&amp;quot;: [1, 2], &amp;quot;b&amp;quot;: [3, 4]})
df.to_numpy()

[[1 3]
 [2 4]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can directly access the array and get a view instead of a copy. This is much faster than copying
all data. We can now operate on the NumPy array and potentially modify it inplace, which will also
update the DataFrame and potentially all other DataFrames that share data. This becomes much more
complicated with Copy-on-Write, since we removed many defensive copies. Many more DataFrames will 
now share memory with each other.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;to_numpy&lt;/code&gt; and &lt;code&gt;.values&lt;/code&gt; will return a read-only array because of this. This means that the
resulting array is not writeable.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;a&amp;quot;: [1, 2], &amp;quot;b&amp;quot;: [3, 4]})
arr = df.to_numpy()

arr[0, 0] = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will trigger a &lt;code&gt;ValueError&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ValueError: assignment destination is read-only
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can avoid this in two different ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trigger a copy manually if you want to avoid updating DataFrames that share memory with your array.&lt;/li&gt;
&lt;li&gt;Make the array writeable. This is a more performant solution but circumvents Copy-on-Write rules, so
  it should be used with caution.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;arr.flags.writeable = True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are cases where this is not possible. One common occurrence is, if you are accessing a single
column which was backed by PyArrow:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ser = pd.Series([1, 2], dtype=&amp;quot;int64[pyarrow]&amp;quot;)
arr = ser.to_numpy()
arr.flags.writeable = True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This returns a &lt;code&gt;ValueError&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ValueError: cannot set WRITEABLE flag to True of this array
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Arrow arrays are immutable, hence it is not possible to make the NumPy array writeable. The conversion
from Arrow to NumPy is zero-copy in this case.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We've looked at the most invasive Copy-on-Write related changes. These changes will become the
default behavior in pandas 3.0. We've also investigated how we can adapt our code to avoid breaking
our code when Copy-on-Write is enabled. The upgrade process should be pretty smooth if you can avoid
these patterns.&lt;/p&gt;</content><category term="posts"></category><category term="pandas"></category><category term="copy-on-write"></category></entry><entry><title>Deep Dive into pandas Copy-on-Write Mode - Part II</title><link href="https://phofl.github.io/cow-deep-dive-optimizations.html" rel="alternate"></link><published>2023-08-17T00:00:00+02:00</published><updated>2023-08-17T00:00:00+02:00</updated><author><name>Patrick Hoefler</name></author><id>tag:phofl.github.io,2023-08-17:/cow-deep-dive-optimizations.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Explaining how Copy-on-Write optimizes performance&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://medium.com/towards-data-science/deep-dive-into-pandas-copy-on-write-mode-part-i-26982e7408c6"&gt;first post&lt;/a&gt; 
explained how the Copy-on-Write mechanism works. It highlights some ares where copies are introduced
into the workflow. This post will focus
on optimizations that ensure that this won't slow the average workflow down.&lt;/p&gt;
&lt;p&gt;We utilize a technique that pandas internals use …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Explaining how Copy-on-Write optimizes performance&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://medium.com/towards-data-science/deep-dive-into-pandas-copy-on-write-mode-part-i-26982e7408c6"&gt;first post&lt;/a&gt; 
explained how the Copy-on-Write mechanism works. It highlights some ares where copies are introduced
into the workflow. This post will focus
on optimizations that ensure that this won't slow the average workflow down.&lt;/p&gt;
&lt;p&gt;We utilize a technique that pandas internals use to avoid copying the whole DataFrame when it's not 
necessary and thus, increase performance. &lt;/p&gt;
&lt;h2 id="removal-of-defensive-copies"&gt;Removal of defensive copies&lt;/h2&gt;
&lt;p&gt;Let's start with the most impactful improvement. Many pandas methods performed defensive copies
to avoid side effects to protect against inplace modifications later on.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;a&amp;quot;: [1, 2, 3], &amp;quot;b&amp;quot;: [4, 5, 6]})
df2 = df.reset_index()
df2.iloc[0, 0] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is no need to copy the data in &lt;code&gt;reset_index&lt;/code&gt;, but returning a view would introduce side
effects when modifying the result, e.g. &lt;code&gt;df&lt;/code&gt; would be updated as well. Hence, a defensiv copy is
performed in &lt;code&gt;reset_index&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;All these defensive copies are no longer there when Copy-on-Write is enabled. This affects many
methods. A full list can be found &lt;a href="https://pandas.pydata.org/docs/user_guide/copy_on_write.html#copy-on-write-optimizations"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Additionally, selecting a columnar subset of a DataFrame will now always return a view instead of
a copy as before.&lt;/p&gt;
&lt;p&gt;Let's look at what this means performance-wise when we combine some of these methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pandas as pd
import numpy as np

N = 2_000_000
int_df = pd.DataFrame(
    np.random.randint(1, 100, (N, 10)), 
    columns=[f&amp;quot;col_{i}&amp;quot; for i in range(10)],
)
float_df = pd.DataFrame(
    np.random.random((N, 10)), 
    columns=[f&amp;quot;col_{i}&amp;quot; for i in range(10, 20)],
)
str_df = pd.DataFrame(
    &amp;quot;a&amp;quot;, 
    index=range(N), 
    columns=[f&amp;quot;col_{i}&amp;quot; for i in range(20, 30)],
)

df = pd.concat([int_df, float_df, str_df], axis=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This creates a DataFrame with 30 columns, 3 different dtypes and 2 million rows. Let's execute
the following method chain on this DataFrame:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;%%timeit
(
    df.rename(columns={&amp;quot;col_1&amp;quot;: &amp;quot;new_index&amp;quot;})
    .assign(sum_val=df[&amp;quot;col_1&amp;quot;] + df[&amp;quot;col_2&amp;quot;])
    .drop(columns=[&amp;quot;col_10&amp;quot;, &amp;quot;col_20&amp;quot;])
    .astype({&amp;quot;col_5&amp;quot;: &amp;quot;int32&amp;quot;})
    .reset_index()
    .set_index(&amp;quot;new_index&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All of these methods perform a defensiv copy without CoW enabled.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Performance without CoW:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.45 s ± 293 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Performance with CoW enabled:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*13.7 ms ± 286 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An improvement by roughly a factor of 200. I chose this example explicitly to illustrate the
potential benefits of CoW. Not every method will get that much faster.&lt;/p&gt;
&lt;h2 id="optimizing-copies-triggered-by-inplace-modifications"&gt;Optimizing copies triggered by inplace modifications&lt;/h2&gt;
&lt;p&gt;The previous section illustrated many methods where a defensiv copy is no longer necessary.
CoW guarantees that you can't modify two objects at once. This means that we have to introduce
a copy when the same data is referenced by two DataFrames. Let's look at techniques to make
these copies as efficient as possible.&lt;/p&gt;
&lt;p&gt;The previous post showed that the following might trigger a copy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df.iloc[0, 0] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The copy is triggered if the data that is backing &lt;code&gt;df&lt;/code&gt; is referenced by another DataFrame.
We assume that our DataFrame has &lt;code&gt;n&lt;/code&gt; integer columns, e.g. is backed by a single Block.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/optimizations/cow_one_block.svg"&gt;&lt;/p&gt;
&lt;p&gt;Our Reference tracking object is also referencing another Block, so we can not modify the DataFrame
inplace without modifying another object. A naive approach would be to copy the whole block and be
done with it.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/optimizations/cow_one_block_naive.svg"&gt;&lt;/p&gt;
&lt;p&gt;This would set up a new reference tracking object and create a new Block that is backed by a fresh
NumPy array. This Block doesn't have any more references, so another operation would be able to 
modify it inplace again. This approach copies &lt;code&gt;n-1&lt;/code&gt; columns that we don't necessarily have to 
copy. We utilize a technique we call Block splitting to avoid this.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/optimizations/cow_one_block_splitting.svg"&gt;&lt;/p&gt;
&lt;p&gt;Internally, only the first column is copied. All other columns are taken as views on the previous 
array. The new Block does not share any references with other columns. The old Block still shares
references with other objects since it is only a view on the previous values.&lt;/p&gt;
&lt;p&gt;There is one disadvantage to this technique. The initial array has &lt;code&gt;n&lt;/code&gt; columns. We created a
view on columns &lt;code&gt;2&lt;/code&gt; till &lt;code&gt;n&lt;/code&gt;, but this keeps the whole array alive. We also added a new array
with one column for the first column. This will keep a bit more memory alive than necessary. &lt;/p&gt;
&lt;p&gt;This system directly translates to DataFrames with different dtypes. All Blocks that are not
modified at all are returned as is and only Blocks that are modified inplace are split.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/optimizations/cow_two_blocks.svg"&gt;&lt;/p&gt;
&lt;p&gt;We now set a new value into column &lt;code&gt;n+1&lt;/code&gt; the float Block to create a view on columns &lt;code&gt;n+2&lt;/code&gt;
to &lt;code&gt;m&lt;/code&gt;. The new Block will only back column &lt;code&gt;n+1&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df.iloc[0, n+1] = 100.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/optimizations/cow_two_blocks_split.svg"&gt;&lt;/p&gt;
&lt;h2 id="methods-that-can-operate-inplace"&gt;Methods that can operate inplace&lt;/h2&gt;
&lt;p&gt;The indexing operations we looked at don't generally create a new object; they modify
the existing object inplace, inlcuding the data of said object. Another group of pandas methods does
not touch the data of the DataFrame at all. One prominent example is &lt;code&gt;rename&lt;/code&gt;. Rename only changes
the labels. These methods can utilize the lazy-copy mechanism mentioned above.&lt;/p&gt;
&lt;p&gt;There is another third group of methods that can actually be done inplace, like &lt;code&gt;replace&lt;/code&gt; or
&lt;code&gt;fillna&lt;/code&gt;. These will always trigger a copy.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df2 = df.replace(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Modifying the data inplace without triggering a copy would modify &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;, which violates
CoW rules. This is one of the reasons why we consider keeping the &lt;code&gt;inplace&lt;/code&gt; keyword for these
methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df.replace(..., inplace=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would get rid of this problem. It's still an open proposal and might go into a different
direction. That said, this only pertains to columns that are actually
changed; all other columns are returned as views anyway. This means that only one column is copied
if your value is only found in one column.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We investigate how CoW changes pandas internal behavior and how this will translate to improvements
in your code. Many methods will get faster with CoW, while we will see a slowdown in a couple of
indexing related operations. Previously, these operations always operated inplace, which might have
produced side effects. These side effects are gone with CoW and a modification on one DataFrame 
object will never impact another.&lt;/p&gt;
&lt;p&gt;The next post in this series will explain how you can update your code to be compliant
with CoW. Also, we will explain which patterns to avoid in the future.&lt;/p&gt;
&lt;p&gt;Thank you for reading. Feel free to reach out to share your thoughts and feedback 
about Copy-on-Write.&lt;/p&gt;</content><category term="posts"></category><category term="pandas"></category><category term="copy-on-write"></category><category term="performance"></category></entry><entry><title>Deep Dive into pandas Copy-on-Write Mode - Part I</title><link href="https://phofl.github.io/cow-deep-dive.html" rel="alternate"></link><published>2023-08-09T00:00:00+02:00</published><updated>2023-08-09T00:00:00+02:00</updated><author><name>Patrick Hoefler</name></author><id>tag:phofl.github.io,2023-08-09:/cow-deep-dive.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Explaining how Copy-on-Write works internally&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://medium.com/gitconnected/welcoming-pandas-2-0-194094e4275b"&gt;pandas 2.0&lt;/a&gt; was released in 
early April and brought many improvements to the new Copy-on-Write (CoW)
mode. The feature is expected to become the default in pandas 3.0, which is scheduled for
April 2024 at the moment. There are no plans for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Explaining how Copy-on-Write works internally&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://medium.com/gitconnected/welcoming-pandas-2-0-194094e4275b"&gt;pandas 2.0&lt;/a&gt; was released in 
early April and brought many improvements to the new Copy-on-Write (CoW)
mode. The feature is expected to become the default in pandas 3.0, which is scheduled for
April 2024 at the moment. There are no plans for a legacy or non-CoW mode.&lt;/p&gt;
&lt;p&gt;This series of posts will explain how Copy-on-Write works internally to help users understand what's 
going on, show how to use it effectively and illustrate how to adapt your code. This will include 
examples on how to leverage the mechanism to get the most efficient performance and also show a 
couple of anti-patterns that will result in unnecessary bottlenecks. I wrote a 
&lt;a href="https://medium.com/towards-data-science/a-solution-for-inconsistencies-in-indexing-operations-in-pandas-b76e10719744"&gt;short introduction&lt;/a&gt;
to Copy-on-Write a couple of months ago.&lt;/p&gt;
&lt;p&gt;I wrote &lt;a href="https://medium.com/better-programming/pandas-internals-explained-545f14a941c1"&gt;a short post&lt;/a&gt; 
that explains the data structure of pandas which will help understand some terminology that is 
necessary for CoW.&lt;/p&gt;
&lt;p&gt;I am part of the pandas core team and was heavily involved in implementing and improving CoW so far. 
I am an open source engineer for &lt;a href="https://www.coiled.io"&gt;Coiled&lt;/a&gt; where I work on Dask, 
including improving the pandas integration and ensuring that Dask is compliant with CoW.&lt;/p&gt;
&lt;h1 id="how-copy-on-write-changes-pandas-behavior"&gt;How Copy-on-Write changes pandas behavior&lt;/h1&gt;
&lt;p&gt;Many of you are probably familiar with the following caveats in pandas:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pandas as pd

df = pd.DataFrame({&amp;quot;student_id&amp;quot;: [1, 2, 3], &amp;quot;grade&amp;quot;: [&amp;quot;A&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;]})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's select the grade-column and overwrite the first row with &lt;code&gt;"E"&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;grades = df[&amp;quot;grade&amp;quot;]
grades.iloc[0] = &amp;quot;E&amp;quot;
df

   student_id grade
0           1     E
1           2     C
2           3     D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, this also updated &lt;code&gt;df&lt;/code&gt; and not only &lt;code&gt;grades&lt;/code&gt;, which has the potential to 
introduce hard to find bugs. CoW will disallow this behavior and ensures that only &lt;code&gt;df&lt;/code&gt; is
updated. We also see a false-positive &lt;code&gt;SettingWithCopyWarning&lt;/code&gt; that doesn't help us here.&lt;/p&gt;
&lt;p&gt;Let's look at a &lt;code&gt;ChainedIndexing&lt;/code&gt; example that is not doing anything:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df[df[&amp;quot;student_id&amp;quot;] &amp;gt; 2][&amp;quot;grades&amp;quot;] = &amp;quot;F&amp;quot;
df

   student_id grade
0           1     A
1           2     C
2           3     D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We again get a &lt;code&gt;SettingWithCopyWarning&lt;/code&gt; but nothing happens to &lt;code&gt;df&lt;/code&gt; in this example. All these
gotchas come down to copy and view rules in NumPy, which is what pandas uses under the hood. pandas
users have to be aware of these rules and how they apply to pandas DataFrames to understand why
similar code patterns produce different results. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CoW cleans up all these inconsistencies&lt;/strong&gt;. Users can only update one object at a time when CoW is
enabled, e.g. &lt;code&gt;df&lt;/code&gt; would be unchanged in our first example since only &lt;code&gt;grades&lt;/code&gt; is updated at
that time and the second example raises a &lt;code&gt;ChainedAssignmentError&lt;/code&gt; instead of doing nothing.
Generally, it won't be possible to update two objects at once, e.g., every object behaves as it
is a copy of the previous object.&lt;/p&gt;
&lt;p&gt;There are many more of these cases, but going through all of them is not in scope here.&lt;/p&gt;
&lt;h1 id="how-it-works"&gt;How it works&lt;/h1&gt;
&lt;p&gt;Let's look into Copy-on-Write in more detail and highlight some facts that are good to know. This is 
the main part of this post and is fairly technical.&lt;/p&gt;
&lt;p&gt;Copy-on-Write promises that &lt;strong&gt;any DataFrame or Series derived from another in&lt;/strong&gt; 
&lt;strong&gt;any way always behaves as a copy&lt;/strong&gt;. This means that it is not possible to modify more than one
object with a single operation, e.g. our first example above would only modify &lt;code&gt;grades&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A very defensive approach to guarantee this would be to copy the DataFrame and its data in every 
operation, which would avoid views in pandas altogether. This would guarantee CoW semantics but 
also incur a huge performance penalty, so this wasn't a viable option. &lt;/p&gt;
&lt;p&gt;We will now dive into the mechanism that ensures that no two objects are updated with a single
operation &lt;strong&gt;and&lt;/strong&gt; that our data isn't unnecessarily copied. The second part is what makes the
implementation interesting.&lt;/p&gt;
&lt;p&gt;We have to know exactly when to trigger a copy to avoid copies that aren't absolutely necessary.
Potential copies are only necessary if we try to mutate the values of one pandas object without
copying it's data. We have to
trigger a copy, if the data of this object is shared with another pandas object.
This means that we have to keep track of whether one NumPy array is referenced by two DataFrames (generally, we have to be
aware if one NumPy array is referenced by two pandas objects, but I will use the term DataFrame for 
simplicity).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;student_id&amp;quot;: [1, 2, 3], &amp;quot;grade&amp;quot;: [1, 2, 3]})
df2 = df[:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This statement creates a DataFrame &lt;code&gt;df&lt;/code&gt; and a view of this DataFrame &lt;code&gt;df2&lt;/code&gt;. View means that
both DataFrames are backed by the same underlying NumPy array. When we look at this with CoW, 
&lt;code&gt;df&lt;/code&gt; has to be aware that &lt;code&gt;df2&lt;/code&gt; references its NumPy array too. This is not sufficient 
though. &lt;code&gt;df2&lt;/code&gt; also has to be aware that &lt;code&gt;df&lt;/code&gt; references its NumPy array. If both objects
are aware that there is another DataFrame referencing the same NumPy array, we can trigger a copy
in case one of them is modified, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df.iloc[0, 0] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;df&lt;/code&gt; is modified inplace here. &lt;code&gt;df&lt;/code&gt; knows that there is another object that references the same data, 
e.g. it triggers a copy. It is not aware which object references the same data, just that there is
another object out there.&lt;/p&gt;
&lt;p&gt;Let's take a look at how we can achieve this. We created an internal class &lt;code&gt;BlockValuesRefs&lt;/code&gt; that
is used to store this information, it points to all DataFrames that reference a given NumPy array. &lt;/p&gt;
&lt;p&gt;There are three different types of operation that can create a DataFrame:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A DataFrame is created from external data, e.g. through &lt;code&gt;pd.DataFrame(...)&lt;/code&gt; or through any
  I/O method.&lt;/li&gt;
&lt;li&gt;A new DataFrame is created through a pandas operation that triggers a copy of the original data,
  e.g. &lt;code&gt;dropna&lt;/code&gt; creates a copy in almost all cases.&lt;/li&gt;
&lt;li&gt;A new DataFrames is created through a pandas operation that &lt;strong&gt;does not&lt;/strong&gt; trigger a copy of the
  original data, e.g. &lt;code&gt;df2 = df.reset_index()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first two cases are simple. When the DataFrame is created, the NumPy arrays that back it are
connected to a fresh &lt;code&gt;BlockValuesRefs&lt;/code&gt; object. These arrays are only referenced by the new
object, so we don't have to keep track of any other objects. The object creates a &lt;code&gt;weakref&lt;/code&gt; that points
to the &lt;code&gt;Block&lt;/code&gt; that wraps the NumPy array and stores this reference internally. The concept
of Blocks is explained &lt;a href="https://medium.com/better-programming/pandas-internals-explained-545f14a941c1"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;a href="https://docs.python.org/3/library/weakref.html"&gt;weakref&lt;/a&gt; creates a reference to any Python
object. It does not keep this object alive when it would normally go out of scope.&lt;/p&gt;
&lt;p&gt;```python
import weakref&lt;/p&gt;
&lt;p&gt;class Dummy:
    def &lt;strong&gt;init&lt;/strong&gt;(self, a):
        self.a = a&lt;/p&gt;
&lt;p&gt;In[1]: obj = Dummy(1)
In[2]: ref = weakref.ref(obj)
In[3]: ref()
Out[3]: &amp;lt;&lt;strong&gt;main&lt;/strong&gt;.Dummy object at 0x108187d60&amp;gt;
In[4]: obj = Dummy(2)
```&lt;/p&gt;
&lt;p&gt;This example creates a Dummy object and a weak reference to this object. Afterward, we assign another
object to the same variable, e.g. the initial object goes out of scope and is garbage collected. The weak reference
does not interfere with this process. If you resolve the weak reference, it will point to &lt;code&gt;None&lt;/code&gt;
instead of the original object.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python
In[5]: ref()
Out[5]: None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This ensures that we don't keep any arrays alive that would otherwise be garbage collected.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's take a look at how these objects are organized:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/copy-on-write.svg"&gt;&lt;/p&gt;
&lt;p&gt;Our example has two columns &lt;code&gt;"a"&lt;/code&gt; and &lt;code&gt;"b"&lt;/code&gt; which both have dtype &lt;code&gt;"int64"&lt;/code&gt;. They are backed
by one Block that holds the data for both columns. The Block holds a hard reference to the reference
tracking object, ensuring that it stays alive as long as the Block is not garbage collected. The
reference tracking object holds a weak reference to the Block. This enables the object to track
the lifecycle of this block but does not prevent garbage collection. The reference tracking object
does not hold a weak reference to any other Block yet.&lt;/p&gt;
&lt;p&gt;These are the easy scenarios. We know that no other pandas object shares the same NumPy array, so we can
simply instantiate a new reference tracking object. &lt;/p&gt;
&lt;p&gt;The third case is more complicated. The new object views the same data as the original object.
This means that both objects point to the same memory. Our operation will create a new Block that
references the same NumPy array, this is called a shallow copy. We now have to register this new 
&lt;code&gt;Block&lt;/code&gt; in our reference tracking mechanism. We will register our new &lt;code&gt;Block&lt;/code&gt; with the reference 
tracking object that is connected to the old object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df2 = df.reset_index(drop=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/copy-on-write_view.svg"&gt;&lt;/p&gt;
&lt;p&gt;Our &lt;code&gt;BlockValuesRefs&lt;/code&gt; now points to the Block that backs the initial &lt;code&gt;df&lt;/code&gt; and the newly created
Block that backs &lt;code&gt;df2&lt;/code&gt;. This ensures that we are always aware about all DataFrames that point to
the same memory. &lt;/p&gt;
&lt;p&gt;We can now ask the reference tracking object how many Blocks pointing to the same NumPy array
are alive. The reference tracking object evaluates the weak references and tells us that more
than one object references the same data. This enables us to trigger a copy internally if one of 
them is modified inplace. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df2.iloc[0, 0] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Block in &lt;code&gt;df2&lt;/code&gt; is copied through a deep copy, creating a new Block that has its own data and
reference tracking object. The original block that was backing &lt;code&gt;df2&lt;/code&gt; can now be garbage collected,
which ensures that the arrays backing &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt; don't share any memory.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/copy-on-write_copy.svg"&gt;&lt;/p&gt;
&lt;p&gt;Let's look at a different scenario.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = None
df2.iloc[0, 0] = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;df&lt;/code&gt; is invalidated before we modify &lt;code&gt;df2&lt;/code&gt;. Consequently, the weakref of our reference tracking
object, that points to the Block that backed &lt;code&gt;df&lt;/code&gt;, evaluates to &lt;code&gt;None&lt;/code&gt;. This enables us to modify 
&lt;code&gt;df2&lt;/code&gt; without triggering a copy.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/copy-on-write_invalidate.svg"&gt;&lt;/p&gt;
&lt;p&gt;Our reference tracking object points to only one DataFrame which enables us to do the operation
inplace without triggering a copy.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reset_index&lt;/code&gt; above creates a view. The mechanism is a bit simpler if we have an operation that 
triggers a copy internally.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df2 = df.copy()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This immediately instantiates a new reference tracking object for our DataFrame &lt;code&gt;df2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../images/deep_dive_cow/copy-on-write_copy_immediately.svg"&gt;&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We have investigated how the Copy-on-Write tracking mechanism works and when we trigger a copy. 
The mechanism defers copies in pandas as much as possible, which is quite different from the non-CoW 
behavior. The reference tracking mechanism keeps track of all DataFrames that share memory,
enabling more consistent behavior in pandas.&lt;/p&gt;
&lt;p&gt;The next part in this series will explain techniques that are used to make this mechanism more
efficient.&lt;/p&gt;
&lt;p&gt;Thank you for reading. Feel free to reach out to share your thoughts and feedback 
about Copy-on-Write.&lt;/p&gt;</content><category term="posts"></category><category term="pandas"></category><category term="copy-on-write"></category><category term="performance"></category></entry><entry><title>A solution for inconsistencies in indexing operations in pandas</title><link href="https://phofl.github.io/cow-introduction.html" rel="alternate"></link><published>2022-12-23T00:00:00+01:00</published><updated>2022-12-23T00:00:00+01:00</updated><author><name>Patrick Hoefler</name></author><id>tag:phofl.github.io,2022-12-23:/cow-introduction.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Get rid of annoying SettingWithCopyWarning messages&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Indexing operations in pandas are quite flexible and thus, have many cases that can behave quite 
different and therefore produce unexpected results. Additionally, it is hard to predict when a 
&lt;code&gt;SettingWithCopyWarningis&lt;/code&gt; raised and what this means exactly. I’ll show a couple of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Get rid of annoying SettingWithCopyWarning messages&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Indexing operations in pandas are quite flexible and thus, have many cases that can behave quite 
different and therefore produce unexpected results. Additionally, it is hard to predict when a 
&lt;code&gt;SettingWithCopyWarningis&lt;/code&gt; raised and what this means exactly. I’ll show a couple of different 
scenarios and how each operation might impact your code. Afterwards, we will look at a new feature 
called &lt;code&gt;Copy on Write&lt;/code&gt; that helps you to get rid of the inconsistencies and of 
&lt;code&gt;SettingWithCopyWarnings&lt;/code&gt;. We will also investigate how this might impact performance and other 
methods in general.&lt;/p&gt;
&lt;h2 id="indexing-operations"&gt;Indexing operations&lt;/h2&gt;
&lt;p&gt;Let’s look at how indexing operations currently work in pandas. If you are already familiar with 
indexing operations, you can jump to the next section. But be aware, there are many cases with 
different forms of behavior. The exact behavor is hard to predict.&lt;/p&gt;
&lt;p&gt;An operation in pandas produces a copy, when the underlying data of the parent DataFrame and the 
new DataFrame are not shared. A view is an object that does share data with the parent object. A 
modification to the view can potentially impact the parent object.&lt;/p&gt;
&lt;p&gt;As of right now, some indexing operations return copies while others return views. The exact 
behavior is hard to predict, even for experienced users. This has been a big annoyance for me in 
the past.&lt;/p&gt;
&lt;p&gt;Let’s start with a DataFrame with two columns:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;user_id&amp;quot;: [1, 2, 3], &amp;quot;score&amp;quot;: [10, 15, 20]})

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;strong&gt;getitem&lt;/strong&gt; operation on a DataFrame or Series returns a subset of the initial object. The subset 
might consist of one or a set of columns, one or a set of rows or a mixture of both. A &lt;strong&gt;setitem&lt;/strong&gt; 
operation on a DataFrame or Series updates a subset of the initial object. The subset itself is 
defined by the arguments to the calls.&lt;/p&gt;
&lt;p&gt;A regular &lt;strong&gt;getitem&lt;/strong&gt; operation on a DataFrame provides a view in most cases:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;view = df[&amp;quot;user_id&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a consequence, the new object &lt;code&gt;view&lt;/code&gt; still references the parent object &lt;code&gt;df&lt;/code&gt; and its data. Hence, 
writing into the view will also modify the parent object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;view.iloc[0] = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;strong&gt;setitem&lt;/strong&gt; operation will consequently update not only our &lt;code&gt;view&lt;/code&gt; but also &lt;code&gt;df&lt;/code&gt;. This 
happens because the underlying data are shared between both objects.&lt;/p&gt;
&lt;p&gt;This is only true, if the column &lt;code&gt;user_id&lt;/code&gt; occurs only once in &lt;code&gt;df&lt;/code&gt;. As soon as &lt;code&gt;user_id&lt;/code&gt; is 
duplicated the &lt;strong&gt;getitem&lt;/strong&gt; operation returns a DataFrame. This means the returned object is a copy 
instead of a view:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame(
    [[1, 10, 2], [3, 15, 4]], 
    columns=[&amp;quot;user_id&amp;quot;, &amp;quot;score&amp;quot;, &amp;quot;user_id&amp;quot;],
)
not_a_view = df[&amp;quot;user_id&amp;quot;]
not_a_view.iloc[0] = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;strong&gt;setitem&lt;/strong&gt; operation does not update &lt;code&gt;df&lt;/code&gt;. We also get our first &lt;code&gt;SettingWithCopyWarning&lt;/code&gt;, even 
though this is a perfectly acceptable operation. The &lt;strong&gt;getitem&lt;/strong&gt; operation itself has many more cases, 
like list-like keys, e.g. &lt;code&gt;df[["user_id"]]&lt;/code&gt;, MultiIndex-columns and many more. I will go into more 
detail in follow-up posts to look at different forms of performing indexing operations and their 
behavior.&lt;/p&gt;
&lt;p&gt;Let’s have a look at another case that is a bit more complicated than a single &lt;strong&gt;getitem&lt;/strong&gt; operation: 
chained indexing. Chained indexing means filtering with a boolean mask followed by a &lt;strong&gt;getitem&lt;/strong&gt; 
operation or the other way around. This is done in one step. We do not create a new variable to 
store the result of the first operation.&lt;/p&gt;
&lt;p&gt;We again start with a regular DataFrame:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;user_id&amp;quot;: [1, 2, 3], &amp;quot;score&amp;quot;: [10, 15, 20]})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can update all &lt;code&gt;user_ids&lt;/code&gt; that have a score greater than 15 through:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df[&amp;quot;user_id&amp;quot;][df[&amp;quot;score&amp;quot;] &amp;gt; 15] = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We take the column &lt;code&gt;user_id&lt;/code&gt; and apply the filter afterwards. This works perfectly fine, because 
the column selection creates a view and the &lt;strong&gt;setitem&lt;/strong&gt; operation updates said view. We can switch 
both operations as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df[df[&amp;quot;score&amp;quot;] &amp;gt; 15][&amp;quot;user_id&amp;quot;] = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This execution order produces another &lt;code&gt;SettingWithCopyWarning&lt;/code&gt;. In contrast to our earlier example, 
nothing happens. The DataFrame &lt;code&gt;df&lt;/code&gt; is not modified. This is a silent no-operation. The boolean 
mask always creates a copy of the initial DataFrame. Hence, the initial &lt;strong&gt;getitem&lt;/strong&gt; operation returns 
a copy. The return value is not assigned to any variable and is only a temporary result. The 
setitem operation updates this temporary copy. As a result, the modification is lost. The fact 
that masks return copies while column selections return views is an implementation detail. 
Ideally, such implementation details should not be visible.&lt;/p&gt;
&lt;p&gt;Another approach of doing this is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;new_df = df[df[&amp;quot;score&amp;quot;] &amp;gt; 15]
new_df[&amp;quot;user_id&amp;quot;] = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This operation updates &lt;code&gt;new_df&lt;/code&gt; as intended but shows a &lt;code&gt;SettingWithCopyWarning&lt;/code&gt; anyway, because we 
can not update &lt;code&gt;df&lt;/code&gt;. Most of us probably never want to update the initial object (e.g. &lt;code&gt;df&lt;/code&gt;) in this 
scenario, but we get the warning anyway. In my experience this leads to unnecessary copy statements 
scattered over the code base.&lt;/p&gt;
&lt;p&gt;This is just a small sample of current inconsistencies and annoyances in indexing operations.&lt;/p&gt;
&lt;p&gt;Since the actual behavior is hard to predict, this forces many defensive copies in other methods. 
For example,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dropping of columns&lt;/li&gt;
&lt;li&gt;setting a new index&lt;/li&gt;
&lt;li&gt;resetting the index&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All copy the underlying data. These copies are not necessary from an implementation perspective. 
The methods could return views pretty easily, but returning views would lead to unpredictable 
behavior later on. Theoretically, one &lt;strong&gt;setitem&lt;/strong&gt; operation could propagate through the whole 
call-chain, updating many DataFrames at once.&lt;/p&gt;
&lt;h2 id="copy-on-write"&gt;Copy on Write&lt;/h2&gt;
&lt;p&gt;Let’s look at how a new feature called “Copy on Write” (CoW) helps us to get rid of these 
inconsistencies in our code base. CoW means that &lt;strong&gt;any DataFrame or Series derived from another in&lt;/strong&gt; 
&lt;strong&gt;any way always behaves as a copy&lt;/strong&gt;. As a consequence, we can only change the values of an object 
through modifying the object itself. CoW disallows updating a DataFrame or a Series that shares 
data with another DataFrame or Series object inplace. With this information, we can again look at 
our initial example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;user_id&amp;quot;: [1, 2, 3], &amp;quot;score&amp;quot;: [10, 15, 20]})
view = df[&amp;quot;user_id&amp;quot;]
view.iloc[0] = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;strong&gt;getitem&lt;/strong&gt; operation provides a view onto &lt;code&gt;df&lt;/code&gt; and it’s data. The &lt;strong&gt;setitem&lt;/strong&gt; operation triggers a copy 
of the underlying data before &lt;code&gt;10&lt;/code&gt; is written into the first row. Hence, the operation won't modify 
&lt;code&gt;df&lt;/code&gt;. An advantage of this behavior is, that we don’t have to worry about &lt;code&gt;user_id&lt;/code&gt; being potentially
duplicated or using &lt;code&gt;df[["user_id"]]&lt;/code&gt; instead of &lt;code&gt;df["user_id"]&lt;/code&gt;. All these cases behave exactly the 
same and no annoying warning is shown.&lt;/p&gt;
&lt;p&gt;Triggering a copy before updating the values of the object has performance implications. This 
will most certainly cause a small slowdown for some operations. On the other side, a lot of other 
operations can &lt;strong&gt;avoid&lt;/strong&gt; defensive copies and thus improve performance tremendously. The following 
operations can all return views with CoW:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dropping columns&lt;/li&gt;
&lt;li&gt;setting a new index&lt;/li&gt;
&lt;li&gt;resetting the index&lt;/li&gt;
&lt;li&gt;and many more.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s consider the following DataFrame:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;na = np.array(np.random.rand(1_000_000, 100))
cols = [f&amp;quot;col_{i}&amp;quot; for i in range(100)]
df = pd.DataFrame(na, columns=cols)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;add_prefix&lt;/code&gt; adds the given string (e.g. &lt;code&gt;test&lt;/code&gt;) to the beginning of every column name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df.add_prefix(&amp;quot;test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without CoW, this will copy the data internally. This is not necessary when looking solely at the 
operation. But since returning a view can have side effects, the method returns a copy. As a 
consequence, the operation itself is pretty slow:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;482 ms ± 3.43 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This takes quite long. We practically only modify 100 string literals without touching the data at 
all. Returning a view provides a significant speedup in this scenario:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;46.4 µs ± 1.04 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same operation runs multiple orders of magnitude faster. More importantly, the running time of 
&lt;code&gt;add_prefix&lt;/code&gt; is &lt;strong&gt;constant&lt;/strong&gt; when using CoW and does not depend on the size of your DataFrame. This 
operation was run on the main branch of pandas.&lt;/p&gt;
&lt;p&gt;The copy is only necessary, if two different objects share the same underlying data. In the 
example above, &lt;code&gt;view&lt;/code&gt; and &lt;code&gt;df&lt;/code&gt; both reference the same data. If the data is exclusive to one &lt;code&gt;DataFrame&lt;/code&gt; 
object, no copy is needed, we can continue to modify the data inplace:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df = pd.DataFrame({&amp;quot;user_id&amp;quot;: [1, 2, 3], &amp;quot;score&amp;quot;: [10, 15, 20]})
df.iloc[0] = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case the &lt;strong&gt;setitem&lt;/strong&gt; operation will continue to operate inplace without triggering a copy.&lt;/p&gt;
&lt;p&gt;As a consequence, all the different scenarios that we have seen initially have exactly the same 
behavior now. We don’t have to worry about subtle inconsistencies anymore.&lt;/p&gt;
&lt;p&gt;Another case that currently has strange and hard to predict behavior is chained indexing. Chained 
indexing under CoW will &lt;strong&gt;never&lt;/strong&gt; work. This is a direct consequence of the CoW mechanism. The initial 
selection of columns might return a view, but a copy is triggered when we perform the subsequent 
setitem operation. Fortunately, we can easily modify our code to avoid chained indexing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df[&amp;quot;user_id&amp;quot;][df[&amp;quot;score&amp;quot;] &amp;gt; 15] = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use &lt;code&gt;loc&lt;/code&gt; to do both operations at once:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df.loc[df[&amp;quot;score&amp;quot;] &amp;gt; 15, &amp;quot;user_id&amp;quot;] = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Summarizing, every object that we create behaves like a copy of the parent object. We can not 
accidentally update an object other than the one we are currently working with.&lt;/p&gt;
&lt;h2 id="how-to-try-it-out"&gt;How to try it out&lt;/h2&gt;
&lt;p&gt;You can try the CoW feature since pandas 1.5.0. Development is still ongoing, but the general 
mechanism works already.&lt;/p&gt;
&lt;p&gt;You can either set the CoW flag globally through on of the following statements:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;pd.set_option(&amp;quot;mode.copy_on_write&amp;quot;, True)
pd.options.mode.copy_on_write = True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, you can enable CoW locally with:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with pd.option_context(&amp;quot;mode.copy_on_write&amp;quot;, True):
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We have seen that indexing operations in pandas have many edge cases and subtle differences in 
behavior that are hard to predict. CoW is a new feature aimed at addressing those differences. 
It can potentially impact performance positively or negatively based on what we are trying to do 
with our data. The full proposal for CoW can be found 
&lt;a href="https://docs.google.com/document/d/1ZCQ9mx3LBMy-nhwRl33_jgcvWo9IWdEfxDNQ2thyTb0/edit#heading=h.iexejdstiz8u"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thank you for reading. Feel free to reach out to share your thoughts and feedback 
on indexing and Copy on Write. I will write follow-up posts focused on this topic and pandas in 
general.&lt;/p&gt;</content><category term="posts"></category><category term="pandas"></category><category term="copy-on-write"></category></entry></feed>